#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Функция для чтения строк из файла
long long getline(char** line, size_t* line_cap, FILE* file) {
    // Буффер в который будут читаться куски файла
    char buffer[128];

    // Если указатель на строку равен NULL или емкость строки равна нулю, то
    // выделяем память под считанную строку размером буффера
    // и устанавливаем емкость
    if (*line == NULL || *line_cap == 0) {
        *line_cap = sizeof(buffer);
        *line = malloc(*line_cap);
    }

    // Общий размер считанной конечной строки
    size_t line_len = 0;
    // Читаем куски файла размером буффера, пока не дойдем до конца файла
    while (fgets(buffer, sizeof(buffer), file)) {
        // Получаем длину строки в буффере
        size_t buf_len = strlen(buffer);

        // Если общая длина считанной строки + длина строки в буффере больше или равна емкости конечной строки, то
        // увеличиваем емкость в 2 раза и перевыделяем память под конечную строку
        if (line_len + buf_len >= *line_cap) {
            *line_cap *= 2;
            *line = realloc(*line, *line_cap);
        }

        // Количество байт которые нужно скопировать в конечную строку
        size_t bytes_to_copy = buf_len;
        // Если на конце строки в буффере стоит символ перевода строки
        // уменьшаем количество байт к копированию на один,
        // таким образом символ перевода строки не попадем в конечную строку
        if (buffer[buf_len - 1] == '\n') {
            bytes_to_copy -= 1;
        }

        // Копируем строку из буффера в конец конечной строки
        memcpy((*line) + line_len, buffer, bytes_to_copy);
        line_len += bytes_to_copy;

        // Если на конце строки в буффере стоит символ перевода строки
        // значит мы считали всю строку, поэтому ставим в конец конечной строки
        // терминирующий ноль и возвращаем длину конечной строки
        if (buffer[buf_len - 1] == '\n') {
            (*line)[line_len] = '\0';
            return line_len;
        }
    }

    // Возвращаем -1, сигнализируя о том, что мы дошли до конца файла,
    // но так и не прочитали строку (не нашли символ перевода строки)
    return -1;
}

int main(int argc, char** argv) {
    // Проверяем количество переданных аргументов
    // 1 аргумент - путь до программы
    // 2 аргумент - путь до файла 
    if (argc < 2) {
        // Сообщаем пользователю, что он не предоставил путь до файла
        printf("You didn't provide a path to a file.\n");
        return 1;
    }

    // Открываем файл в режиме чтения
    FILE* f = fopen(argv[1], "r");
    // Если файл не удалось открыть, сообщаем об этом пользователю
    // и завершаем программу с кодом ошибки
    if (f == NULL) {
        printf("Couldn't open the file.\n");
        return 1;
    }
    
    // Строка
    char* line = NULL;
    // Емкость строки
    size_t line_cap = 0;
    // Количество символов в строке
    long long line_len = 0;

    // Количество прочитанных строк
    size_t lines_count = 0;
    // Емкость массива строк
    size_t lines_cap = 10;
    // Выделяем память под 10 возможных строк
    char** lines = malloc(lines_cap * sizeof(char*));
    
    // Читаем строки пока не достигнем конца файла
    while ((line_len = getline(&line, &line_cap, f)) >= 0) {
        // Если количество строк больше или равно емкости массива строк
        // Увеличиваем емкость в 2 раза и перевыделяем память под новую емкость
        if (lines_count >= lines_cap) {
            lines_cap *= 2;
            lines = realloc(lines, lines_cap * sizeof(char*));
        }

        // Копируем прочитанную строку в массив строк
        // Выделяем память под строку (длина строки + нул-терминатор)
        char* l = malloc(line_len + 1);
        // Копируем строку в выделенную память
        memcpy(l, line, line_len + 1);
        // Добавляем скопированную строку в массив строк и увеличиваем количество строк на один
        lines[lines_count++] = l;
    }


    // Закрываем файл
    fclose(f);

    // Выводим все прочитанные строки с обратном порядке 
    for (size_t i = lines_count - 1; i >= 0; --i) {
        printf("%s\n", lines[i]);
    }

    // Освобождаем выделенную память под строку
    free(line);
    // Освобождаем выделенную память под массив прочитанных строк
    free(lines);

    // Возвращаем нулевое значение, означающее, что программа завершилась без ошибок
    return 0;
}