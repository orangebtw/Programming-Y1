#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Функция для чтения строк из файла
long long readline(char** line, size_t* line_cap, FILE* file) {
    // Буффер в который будут читаться куски файла
    char buffer[128];

    // Если указатель на строку равен NULL или емкость строки равна нулю, то
    // выделяем память под считанную строку размером буффера
    // и устанавливаем емкость
    if (*line == NULL || *line_cap == 0) {
        *line_cap = sizeof(buffer);
        *line = malloc(*line_cap);
    }

    // Общий размер считанной конечной строки
    size_t line_len = 0;
    // Читаем куски файла размером буффера, пока не дойдем до конца файла
    while (fgets(buffer, sizeof(buffer), file)) {
        // Получаем длину строки в буффере
        size_t buf_len = strlen(buffer);

        // Если общая длина считанной строки + длина строки в буффере больше или равна емкости конечной строки, то
        // увеличиваем емкость в 2 раза и перевыделяем память под конечную строку
        if (line_len + buf_len >= *line_cap) {
            *line_cap *= 2;
            *line = realloc(*line, *line_cap);
        }

        // Количество байт которые нужно скопировать в конечную строку
        size_t bytes_to_copy = buf_len;
        // Если на конце строки в буффере стоит символ перевода строки
        // уменьшаем количество байт к копированию на один,
        // таким образом символ перевода строки не попадем в конечную строку
        if (buffer[buf_len - 1] == '\n') {
            bytes_to_copy -= 1;
        }

        // Копируем строку из буффера в конец конечной строки
        memcpy((*line) + line_len, buffer, bytes_to_copy);
        line_len += bytes_to_copy;

        // Если на конце строки в буффере стоит символ перевода строки
        // значит мы считали всю строку, поэтому ставим в конец конечной строки
        // терминирующий ноль и возвращаем длину конечной строки
        if (buffer[buf_len - 1] == '\n') {
            (*line)[line_len] = '\0';
            return line_len;
        }
    }

    // Возвращаем -1, сигнализируя о том, что мы дошли до конца файла,
    // но так и не прочитали строку (не нашли символ перевода строки)
    return -1;
}

// Описание структуры односвязного списка
typedef struct linked_list {
    long value;
    struct linked_list* next;
} LinkedList;

// Функция для вывода элементво связного списка
void linked_list_print(LinkedList* head) {
    if (head == NULL) return;

    while (head != NULL) {
        printf("%ld\n", head->value);
        head = head->next;
    }
}

// Функция для упорядоченного добавления элемента в связный список
LinkedList* linked_list_add_sorted(LinkedList* list, long value) {
    // Выделяем память под новый элемент списка
    LinkedList* node = malloc(sizeof(LinkedList));
    node->value = value;
    node->next = NULL;

    // Указатель на текущий элемент списка
    LinkedList* head = list;
    // Указатель на место куда нужно поставить новый элемент
    LinkedList** pos = &list;
    // Идем по списку пока не найдем нулевой элемент или пока значение текущего элемента
    // не будет больше значения добавляемого элемента
    while (head != NULL && head->value < value) {
        // Обновляем указатель на место для нового элемента 
        pos = &head->next;
        // Обновляем указатель на текущий элемент
        head = head->next;
    }
    // Ставим новый элемент на место следующего элемента после 
    *pos = node;
    // Присваиваем указатель на текущий элемент указателю на следующий элемент нового элемента
    node->next = head;

    // Пример алгоритма:
    //   Текущие состояние списка: нет элементов
    //   Добавляем элемент 10
    //   head -> NULL
    //   pos -> место первого элемента
    //   1. если head != NULL и head->value < 10 идем на шаг 2
    //   2. pos = &head->next, идем на шаг 3
    //   3. head = head->next, идем на шаг 4
    //   4. идем на шаг 1
    //   *pos = {10, NULL}
    //   node->next = head

    //   Текущие состояние списка: 10
    //   Добавляем элемент 6
    //   head -> {10, NULL}
    //   pos -> место первого элемента
    //   1. если head != NULL и 10 < 6 идем на шаг 2
    //   2. pos = &head->next, идем на шаг 3
    //   3. head = head->next, идем на шаг 4
    //   4. идем на шаг 1
    //   *pos = {6, NULL}
    //   node->next = head

    //   Текущие состояние списка: 6, 10
    //   Добавляем элемент 8
    //   head -> {6, NULL}
    //   pos -> место первого элемента

    //   1. если head != NULL и 6 < 8 идем на шаг 2
    //   2. pos = &head->next, идем на шаг 3
    //   3. head = head->next, идем на шаг 4
    //   4. идем на шаг 1

    //   head -> {10, NULL}
    //   pos -> место второго элемента
    //   1. если head != NULL и 10 < 8 идем на шаг 2
    //   2. pos = &head->next, идем на шаг 3
    //   3. head = head->next, идем на шаг 4
    //   4. идем на шаг 1

    //   *pos = {8, NULL}
    //   node->next = head


    // Возвращаем (возможно) обновленный указатель на первый элемент списка
    return list;
}

int main(int argc, char** argv) {
    // Проверяем, что количество аргументов достаточно
    // 1 аргумент - путь к программе
    // 2 аргумент - путь к файлу
    if (argc < 2) {
        printf("You didn't provide the file.\n");
        return 1;
    }

    // Открываем файл в текстовом режиме чтения
    FILE* f = fopen(argv[1], "r");
    // Если не удалось открыть файл сообщаем об этом пользователю и завершаем программу с кодом ошибки
    if (f == NULL) {
        printf("Couldn't open the file.\n");
        return 1;
    }

    // Указатель на первый элемент списка
    LinkedList* list = {0};

    // Считанная строка
    char* line = NULL;
    // Емкость считанной строки
    size_t line_cap = 0;

    // Читаем строку из файла пока не дойдем до конца файла
    while (readline(&line, &line_cap, f) >= 0) {
        // Конвертируем строку в число
        char* read = line;
        long v = strtol(read, &read, 10);

        // Добавляем элемент в список с сохранением порядка
        // и (возможно) обновляем указатель на первый элемент списка
        list = linked_list_add_sorted(list, v);
    }

    // Освобождаем память под строку, т.к. она больше не нужно
    free(line);

    // Закрываем файл, т.к. мы закончили его читать
    fclose(f);

    // Выводим элементы списка
    linked_list_print(list);

    // Возвращаем нулевое значение, сообщая, что программа завершилась без ошибок
    return 0;
}