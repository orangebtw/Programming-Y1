#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Функция для чтения строк из файла
long long getline(char** line, size_t* line_cap, FILE* file) {
    // Буффер в который будут читаться куски файла
    char buffer[128];

    // Если указатель на строку равен NULL или емкость строки равна нулю, то
    // выделяем память под считанную строку размером буффера
    // и устанавливаем емкость
    if (*line == NULL || *line_cap == 0) {
        *line_cap = sizeof(buffer);
        *line = malloc(*line_cap);
    }

    // Общий размер считанной конечной строки
    size_t line_len = 0;
    // Читаем куски файла размером буффера, пока не дойдем до конца файла
    while (fgets(buffer, sizeof(buffer), file)) {
        // Получаем длину строки в буффере
        size_t buf_len = strlen(buffer);

        // Если общая длина считанной строки + длина строки в буффере больше или равна емкости конечной строки, то
        // увеличиваем емкость в 2 раза и перевыделяем память под конечную строку
        if (line_len + buf_len >= *line_cap) {
            *line_cap *= 2;
            *line = realloc(*line, *line_cap);
        }

        // Количество байт которые нужно скопировать в конечную строку
        size_t bytes_to_copy = buf_len;
        // Если на конце строки в буффере стоит символ перевода строки
        // уменьшаем количество байт к копированию на один,
        // таким образом символ перевода строки не попадем в конечную строку
        if (buffer[buf_len - 1] == '\n') {
            bytes_to_copy -= 1;
        }

        // Копируем строку из буффера в конец конечной строки
        memcpy((*line) + line_len, buffer, bytes_to_copy);
        line_len += bytes_to_copy;

        // Если на конце строки в буффере стоит символ перевода строки
        // значит мы считали всю строку, поэтому ставим в конец конечной строки
        // терминирующий ноль и возвращаем длину конечной строки
        if (buffer[buf_len - 1] == '\n') {
            (*line)[line_len] = '\0';
            return line_len;
        }
    }

    // Возвращаем -1, сигнализируя о том, что мы дошли до конца файла,
    // но так и не прочитали строку (не нашли символ перевода строки)
    return -1;
}

int main(int argc, char** argv) {
    // Проверяем, что аргументов достаточно
    // 1 аргумент - путь к программе
    // 2 аргумент - путь к файлу с первой матрицей
    // 3 аргумент - путь к файлу со второй матрицей
    if (argc < 3) {
        printf("You didn't provide files.\n");
        return 1;
    }

    // Открываем файл с первой матрицей в текстовом режиме чтения
    FILE* f1 = fopen(argv[1], "r");
    // Если не удалось открыть файл, то сообщаем об этом пользователю
    // и завершаем программу с кодом ошибки
    if (f1 == NULL) {
        printf("Couldn't open file: \"%s\"", argv[1]);
        return 1;
    }

    // Открываем файл со второй матрицей в текстовом режиме чтения
    FILE* f2 = fopen(argv[2], "r");
    // Если не удалось открыть файл, то сообщаем об этом пользователю,
    // закрываем файл первый файл и завершаем программу с кодом ошибки
    if (f2 == NULL) {
        printf("Couldn't open file: \"%s\"", argv[2]);
        fclose(f1);
        return 1;
    }

    // Считанная строка из файла
    char* line = NULL;
    // Емкость считанной строки
    size_t line_cap = 0;

    // Количество строк первой матрицы
    size_t m1_r = 0;
    // Количество столбцов первой матрицы
    size_t m1_c = 0;
    // Количество строк второй матрицы
    size_t m2_r = 0;
    // Количество столбцов второй матрицы
    size_t m2_c = 0;

    // Считываем первую строку из файла с первой матрицей
    // Если не удалось считать строку сообщаем об этом пользователю,
    // закрываем оба файла и завершаем программу с кодом ошибки
    if (getline(&line, &line_cap, f1) < 0) {
        printf("The file is incorrect.\n");
        fclose(f1);
        fclose(f2);
        return 1;
    }
    
    // Считываем количество строк и столбцов из первой строки файла с первой матрицей
    sscanf(line, "%zu %zu", &m1_r, &m1_c);

    // Считываем первую строку из файла со второй матрицей
    // Если не удалось считать строку сообщаем об этом пользователю,
    // закрываем оба файла и завершаем программу с кодом ошибки
    if (getline(&line, &line_cap, f2) < 0) {
        printf("The file is incorrect.\n");
        fclose(f1);
        fclose(f2);
        return 1;
    }

    // Считываем количество строк и столбцов из первой строки файла со второй матрицей
    sscanf(line, "%zu %zu", &m2_r, &m2_c);

    // Сразу проверяем, что кол-во строк первой матрицей равно кол-ву столбцов второй матрицы
    // Если нет, то сообщаем об этом пользователю, закрываем оба файла и завершаем программу с кодом ошибки
    if (m1_c != m2_r) {
        printf("Matrices cannot be multiplied.\n");
        fclose(f1);
        fclose(f2);
        return 1;
    }

    // Выделяем память под первую матрицу
    float* m1 = malloc(m1_r * m1_c * sizeof(float));
    // Выделяем память под вторую матрицу
    float* m2 = malloc(m2_r * m2_c * sizeof(float));

    // Считываем элементы первой матрицы
    for (size_t i = 0; i < m1_r; ++i) {
        if (getline(&line, &line_cap, f1) < 0) {
            printf("Matrix is wrong.\n");
            return 1;
        }

        char* read = line;
        for (size_t j = 0; j < m1_c; ++j) {
            m1[i * m1_c + j] = strtof(read, &read);
        }
    }

    // Считываем элементы второй матрицы
    for (size_t i = 0; i < m2_r; ++i) {
        if (getline(&line, &line_cap, f2) < 0) {
            printf("Matrix is wrong.\n");
            return 1;
        }

        char* read = line;  
        for (size_t j = 0; j < m2_c; ++j) {
            m2[i * m2_c + j] = strtof(read, &read);
        }
    }

    // Освобождаем память выделенную под чтение строк из файла, т.к. она нам больше не нужна
    free(line);

    // Закрываем оба файла, т.к. они нам больше не нужны
    fclose(f1);
    fclose(f2);

    // Кол-во строк выходной матрицы
    size_t n = m1_r;
    // Кол-во столбцов первой матрицы
    size_t m = m1_c;
    // Кол-во столбцов выходной матрицы
    size_t p = m2_c;

    // ВЫделяем память под выходную матрицу
    float* result = malloc(n * p * sizeof(float));

    // Производим умножение матриц
    for (size_t i = 0; i < n; ++i) {
        for (size_t j = 0; j < p; ++j) {
            result[i * p + j] = 0;
            for (size_t k = 0; k < m; ++k) {
                result[i * p + j] += m1[i * m + k] * m2[k * p + j];
            }
        }
    }

    // Выводим результат
    for (size_t i = 0; i < n; ++i) {
        for (size_t j = 0; j < p; ++j) {
            printf("%.2f ", result[i * p + j]);
        }
        printf("\n");
    }

    // Возвращаем нулевое значение, сообщая, что программа завершилась без ошибок
    return 0;
}